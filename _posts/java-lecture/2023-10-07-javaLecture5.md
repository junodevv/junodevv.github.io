---
title: "[Java] 강의5 웹서버, ISO 7계층, TcP/HTTP 헤더, 클라우드 환경, 동기﹒비동기"
category: Java
tags: java java강의 
published: false
---

자바를 더 깊게 이해하기 위한 itwill 자바 강의 5

-----

# 웹서버

# 1. 서버

- 요청에의해서 폴더 하나를 열어서 공유해 주는것

<img width="478" alt="image" src="https://github.com/junodevv/Algorithm/assets/126752196/5e28c361-f441-4655-9d96-031e2b44ac7c">

- 웹서버는 수동적
        클라이언트의 PULL 요청에 따라 동작함, PULL 방식
        웹서버가 클라이언트에게 주는 걸 PUSH

# 2. Stateful

- 상태지속
        두 개의 컴퓨터?(서버-클라이언트)가 연결된 상태로 지속됨
- A와 B가 원할 때 언제든 메시지를 보낼 수 있음

# 3. Stateless

- 서버-클라이언트 관계에서 클라이언트는 요청만하고 서버는 응답만 하고 그 통신이 끝나면 연결이 끊김

# 4. 웹 인증

- 인증완료해서 신뢰할 수 있는 관계가 된 것 = 세션
- 세션을 갖고 있는 관계 = Stateful

- stateless 관계에서는 이러한 세션이 끊기게 된다는 단점이 있다.
                장점: 많은 요청을 처리 할 수 있다는 점

- 세션에 대해서
    - 서버의 하드디스크에는 세션을 저장해 놓는 공간이 있어서 그곳에 사용자들의 인증정보를 저장해놓는다.
        ex) 사용자A의 세션이 "AC5D" 라면 서버는 요청에 대한 응답을 할 때 데이터 속에 "AC5D"를 담아서 전달해주고 클라이언트는 그 세션을 새로운 요청을 할 떄 요청메시지에 담아서 보낸다.
    - 위의 방식으로 논리적인 stateful 상태를 만들어준다.

# OSI 7계층

# 1. Port(항구)

        항구를 예로들면 목적지: 부산항, 포트: 2번포트 이런식으로 할떄 사용되는게 Port

- 포트는 논리적인 것으로 0 ~ 65536 까지 있다.
- 프로그램에 따라 사용하는 포트의 숫자가 다르다.
- 결론: 각 프로그램과 통신하기 위한 포트번호를 논리적으로 만들어 구분여 사용한다.

# 2. OSI 7계층
        7개로 나눠는 이유: 문서전달 회사가 있다고 할 경우, 사장이 모든일을 할 수 없음
                사장: 문서 기획      , 보고서 읽기
                과장: 문서 생성      , 문서읽기﹒보고서작성
                대리: 문서 보완(오타) , 오타수정
                사원: 문서 전달      , 문서받기
        이런식으로 각자의 역할과 책임을 가지게 함

7계층(Email 통신 예시)

>    - 7층: 응용 계층     -> Email 프로그램,작성
>    - 6층: 표현 계층     -> 암호화, 압축
>    - 5층: 세션 계층     -> 세션 동기화
>    - 4층: 트랜스포트 계층 -> TCP(양방향) / UDP(한방향) 방식 결정
>    - 3층: 네트워크 계층  -> IP 선택(= 목적지 선택, 전세계 모든 컴퓨터에 접근할 수 있는 주소)
>    - 2층: 데이터 계층   -> MAC 어드레스(= LAN카드에 있는 하드웨어 번호)
>    - 1층: 물리 계층    -> 광케이블, 랜선 등

# 3. TCP 헤더

- 서킷 스위칭 방식: 클라이언트A,클라이언트C -> 서버B 가 통신하기 위해 각각 하나씩 물리적인 선으로 연결되어 있어 자유롭게 데이터를 주고 받는다.

- 패킷 스위칭 방식: 클라리언트A, 클라이언트C -> 서버B가 통신하는데 버스선을 이용하는 것
    - 이때 각 클라이언트의 데이터들은 분리되어지는데 이것을 패킷 이라고 한다.
    - A와 C가 동시에 데이터를 보내면 두르이 데이터가 섞여서 도착하기 때문에 쓰레기 데이터가 될 수 있다. 이를 방지하기 위해 **헤더**를 사용한다.
                헤더: 전송하는 데이터를 설명해준다. ex) 데이터를 보낸 곳, 데이터 순서
    - 서버B는 무순서로 받은 데이터들을 헤더를 참고하여 조립한다.

# 4. HTTP 헤더

- MIME 타입

3,4 결론 = 헤더란 보내는 데이터에 대한 설명, 요청시에 보낼 부가설명(보낸곳, 순서 등)

# 클라우드

# 1. 클라우드

- Iaas : Infra as a service 
- saas : Software as s service
        ex) 구글드라이브 -> 구글 문서 작성 등
- paas : Platform as a service
        ex) 일본 Heroku(빈 컴퓨터에 OS,프로그램등이 설치되어있음)

# 동기﹒비동기

# 1. 통기 프로그래밍

- 프로그래밍: 동기 (일의 순서 존재)
        ex) 학교가기 알고리즘: ①일어나기 ②양치,세수 ③아침밥먹기 ④스쿨버스
                양치먼저하고 일어나기? 안되지 
- 데이터: 동기화(데이터 일치)
        ex) i cloud 핸드폰 갤러리와 클라우드의 갤러리의 데이터를 일치 시키는 것

# 2. 비동기 프로그래밍

- 일의 순서가 없다.
        ex) 하루일과 알고리즘: ①빨래(세탁기-1시간) ②청소 ③공부
        -> 일의 순서가 없음
- 위의 예시에서 **동기 프로그래밍**은 빨래가 돌아가는 1시간동안 다른일을 수행 할 수 없음
- 공부를 하는 도중 빨래가 다 되었다면 **공부를 stop**하고 빨래를 널고나서 다시돌아와 공부를 할 수 있음.

- 프로그램예시
        CPU가 한번에 10개의 처리를 할 수 있다고 할 때
        ① 10개 처리(1초)
        ② 10개 처리 후 처리한 기록 하드디스크 저장(1분)
        ③ 10개 처리(1초)
- 여기서, <b class="text-red">동기 프로그램</b>은 10개 처리(1초)한후 기록을 하드디스크에 저장하는 1분동안 CPU가 놀게 되어 효율성이 떨어진다.
- 하지만, <b class="text-blue">비동기 프로그램</b>은 하드디스크에 저장하는 1분동안 기다리지 않고 다음 10개를 바로 처리하기 시작한다. -> 효율성↑, 퍼포먼스↑

-----

# 끝

## reference

[itwill, K-디지털 디지털기초역량 향상을 위한 웹개발 입문 과정](https://www.e-itwill.com/main/index.jsp)
